import { Request, Response } from 'express';
import { prisma } from '../lib/prisma';
import { validationResult } from 'express-validator';

// Strongly-typed DTOs for responses
interface CommentAuthorDTO {
  id: string;
  username: string;
  avatar_url?: string | null;
}

interface CommentDTO {
  id: string;
  content: string;
  createdAt: Date;
  createdAtIso: string;
  updatedAt: Date;
  updatedAtIso: string;
  createdAtFr: string; // localized French representation per requested format
  author: CommentAuthorDTO;
  answerId?: string | null;
  questionId?: string | null;
}

type DateFormat = 'date' | 'datetime' | 'relative';

const formatDateFrDateOnly = (d: Date) => d.toLocaleDateString('fr-FR');
const formatDateFrDateTime = (d: Date) => d.toLocaleString('fr-FR', {
  day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'
});

const formatDateFrRelative = (d: Date) => {
  const now = new Date();
  const sec = Math.floor((now.getTime() - d.getTime()) / 1000);
  if (sec < 60) return `il y a ${sec} seconde${sec > 1 ? 's' : ''}`;
  const min = Math.floor(sec / 60);
  if (min < 60) return `il y a ${min} minute${min > 1 ? 's' : ''}`;
  const hr = Math.floor(min / 60);
  if (hr < 24) return `il y a ${hr} heure${hr > 1 ? 's' : ''}`;
  const days = Math.floor(hr / 24);
  if (days < 30) return `il y a ${days} jour${days > 1 ? 's' : ''}`;
  const months = Math.floor(days / 30);
  if (months < 12) return `il y a ${months} mois`;
  const years = Math.floor(months / 12);
  return `il y a ${years} an${years > 1 ? 's' : ''}`;
};

const formatDateFr = (date?: Date | string | null, format: DateFormat = 'datetime') => {
  if (!date) return '';
  const d = new Date(date);
  if (isNaN(d.getTime())) return '';
  switch (format) {
    case 'date': return formatDateFrDateOnly(d);
    case 'relative': return formatDateFrRelative(d);
    case 'datetime':
    default:
      return formatDateFrDateTime(d);
  }
};

interface AuthRequest extends Request {
  user?: {
    id: string;
    email: string;
  };
}

export const getAnswerComments = async (req: Request, res: Response) => {
  try {
  const { answerId } = req.params;
  const format = (req.query.format as string) as DateFormat || 'datetime';

    const comments = await prisma.comment.findMany({
      where: {
        answerId
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar_url: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    const formatted: CommentDTO[] = comments.map((c: any) => ({
      id: c.id,
      content: c.content,
      createdAt: c.createdAt,
      createdAtIso: (c.createdAt instanceof Date) ? c.createdAt.toISOString() : new Date(c.createdAt).toISOString(),
      updatedAt: c.updatedAt,
      updatedAtIso: (c.updatedAt instanceof Date) ? c.updatedAt.toISOString() : new Date(c.updatedAt).toISOString(),
      createdAtFr: formatDateFr(c.createdAt, format),
      author: {
        id: c.author?.id,
        username: c.author?.username,
        avatar_url: c.author?.avatar_url
      },
      answerId: c.answerId,
      questionId: c.questionId
    }));

    res.json(formatted);
  } catch (error) {
    console.error('Error fetching answer comments:', error);
    res.status(500).json({ message: 'Error fetching comments' });
  }
};

export const getQuestionComments = async (req: Request, res: Response) => {
  try {
  const { questionId } = req.params;
  const format = (req.query.format as string) as DateFormat || 'datetime';

    const comments = await prisma.comment.findMany({
      where: {
        questionId
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar_url: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    const formatted: CommentDTO[] = comments.map((c: any) => ({
      id: c.id,
      content: c.content,
      createdAt: c.createdAt,
      createdAtIso: (c.createdAt instanceof Date) ? c.createdAt.toISOString() : new Date(c.createdAt).toISOString(),
      updatedAt: c.updatedAt,
      updatedAtIso: (c.updatedAt instanceof Date) ? c.updatedAt.toISOString() : new Date(c.updatedAt).toISOString(),
      createdAtFr: formatDateFr(c.createdAt, format),
      author: {
        id: c.author?.id,
        username: c.author?.username,
        avatar_url: c.author?.avatar_url
      },
      answerId: c.answerId,
      questionId: c.questionId
    }));

    res.json(formatted);
  } catch (error) {
    console.error('Error fetching question comments:', error);
    res.status(500).json({ message: 'Error fetching comments' });
  }
};

export const addAnswerComment = async (req: AuthRequest, res: Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
  const { answerId } = req.params;
    const { content } = req.body;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ message: 'Authentication required' });
    }

    const comment = await prisma.comment.create({
      data: {
        content,
        author: { connect: { id: userId } },
        answer: { connect: { id: answerId } }
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar_url: true
          }
        }
      }
    });

    const format = (req.query.format as string) as DateFormat || 'datetime';
    const result: CommentDTO = {
      id: comment.id,
      content: comment.content,
      createdAt: comment.createdAt,
  createdAtIso: comment.createdAt instanceof Date ? comment.createdAt.toISOString() : new Date(comment.createdAt).toISOString(),
      updatedAt: comment.updatedAt,
  updatedAtIso: comment.updatedAt instanceof Date ? comment.updatedAt.toISOString() : new Date(comment.updatedAt).toISOString(),
      createdAtFr: formatDateFr(comment.createdAt, format),
      author: {
        id: comment.author.id,
        username: comment.author.username,
        avatar_url: comment.author.avatar_url
      },
      answerId: comment.answerId,
      questionId: comment.questionId
    };

    res.status(201).json(result);
  } catch (error) {
    console.error('Error adding answer comment:', error);
    res.status(500).json({ message: 'Error adding comment' });
  }
};

export const addQuestionComment = async (req: AuthRequest, res: Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
  const { questionId } = req.params;
    const { content } = req.body;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ message: 'Authentication required' });
    }

    const comment = await prisma.comment.create({
      data: {
        content,
        author: { connect: { id: userId } },
        question: { connect: { id: questionId } }
      },
      include: {
        author: {
          select: {
            id: true,
            username: true,
            avatar_url: true
          }
        }
      }
    });

    const format = (req.query.format as string) as DateFormat || 'datetime';
    const result: CommentDTO = {
      id: comment.id,
      content: comment.content,
      createdAt: comment.createdAt,
  createdAtIso: comment.createdAt instanceof Date ? comment.createdAt.toISOString() : new Date(comment.createdAt).toISOString(),
      updatedAt: comment.updatedAt,
  updatedAtIso: comment.updatedAt instanceof Date ? comment.updatedAt.toISOString() : new Date(comment.updatedAt).toISOString(),
      createdAtFr: formatDateFr(comment.createdAt, format),
      author: {
        id: comment.author.id,
        username: comment.author.username,
        avatar_url: comment.author.avatar_url
      },
      answerId: comment.answerId,
      questionId: comment.questionId
    };

    res.status(201).json(result);
  } catch (error) {
    console.error('Error adding question comment:', error);
    res.status(500).json({ message: 'Error adding comment' });
  }
};
